import { promises as fs } from 'fs';
import Go from './wasm_exec.js';
import { fileURLToPath } from 'url';
export const transform = async (input, options) => {
    return ensureServiceIsRunning().then((service) => service.transform(input, options));
};
export const compile = async (template) => {
    const { default: mod } = await import(`data:text/javascript;charset=utf-8;base64,${Buffer.from(template).toString('base64')}`);
    return mod;
};
let longLivedService;
let ensureServiceIsRunning = () => {
    if (longLivedService)
        return Promise.resolve(longLivedService);
    return startRunningService();
};
const instantiateWASM = async (wasmURL, importObject) => {
    let response = undefined;
    const fetchAndInstantiateTask = async () => {
        const wasmArrayBuffer = await fs.readFile(wasmURL).then((res) => res.buffer);
        return WebAssembly.instantiate(new Uint8Array(wasmArrayBuffer), importObject);
    };
    response = await fetchAndInstantiateTask();
    return response;
};
const startRunningService = async () => {
    const go = new Go();
    const wasm = await instantiateWASM(fileURLToPath(new URL('../astro.wasm', import.meta.url)), go.importObject);
    go.run(wasm.instance);
    const apiKeys = new Set(['transform']);
    const service = Object.create(null);
    for (const key of apiKeys.values()) {
        const globalKey = `__astro_${key}`;
        service[key] = globalThis[globalKey];
        delete globalThis[globalKey];
    }
    longLivedService = {
        transform: (input, options) => new Promise((resolve) => resolve(service.transform(input, options || {}))),
    };
    return longLivedService;
};
